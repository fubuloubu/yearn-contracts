def test_proxy_earn(accounts, ychad, Token, Contract):
    # NOTE: This person has a ton of DAI, but flash loans could be used instead
    # Use Uniswap v2 WETH/DAI pool as it's the top DAI holder
    hacker = accounts.at("0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11", force=True)

    ycrv_zap = Contract("0xbBC81d23Ea2c3ec7e56D39296F0cbB648873a5d3")
    ycrv = Token.at("0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8")
    dai = Token.at("0x6B175474E89094C44Da98b954EedeAC495271d0F")
    vault = Contract.from_explorer("0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c")
    controller = Contract(vault.controller())
    curveYCRVVoter = Contract("0xF147b8125d2ef93FB6965Db97D6746952a133934")
    fixedStrategy = Contract("0x8C6698dC64f69231E3dC509CD7Ad72164D2389F7")
    strategyProxy = Contract(fixedStrategy.proxy())

    # Correctly setups env (since fix is not live)
    controller.approveStrategy(ycrv, fixedStrategy, {"from": ychad})
    controller.setStrategy(ycrv, fixedStrategy, {"from": ychad})
    curveYCRVVoter.setStrategy(strategyProxy, {"from": ychad})
    strategyProxy.approveStrategy(fixedStrategy, {"from": ychad})


    dai.approve(ycrv_zap, 2 ** 256 - 1, {"from": hacker})
    ycrv_zap.add_liquidity([dai.balanceOf(hacker), 0, 0, 0], 0, {"from": hacker})
    assert ycrv.balanceOf(hacker) > 0, "could not obtain ycrv"

    before = ycrv.balanceOf(hacker)
    ycrv.approve(vault, 2 ** 256 - 1, {"from": hacker})

    print(f"vault: {vault.balance() / 1e18:,.0f} yCRV ")
    print(f"hacker: {ycrv.balanceOf(hacker) / 1e18:,.0f} yCRV")

    vault.deposit(ycrv.balanceOf(hacker) // 2, {"from": hacker})
    vault.earn({"from": hacker, "gas_limit": 250000})
    vault.deposit(ycrv.balanceOf(hacker), {"from": hacker})
    vault.earn({"from": hacker})
    vault.withdraw(vault.balanceOf(hacker), {"from": hacker})

    print(f"hacker has earned: {(ycrv.balanceOf(hacker) - before) / 1e18:+,.0f}")

    assert ycrv.balanceOf(hacker) <= before
